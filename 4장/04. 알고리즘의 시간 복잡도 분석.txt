[ 2부 알고리즘 분석 ]

- 개관
    알고리즘(algorithm) 
        : 어떤 작업이 주어졌을 때 컴퓨터가 이 작업을 해결하는 방법
        : 주어진 문제를 해결하는 한 가지 방법을 명료하게 써 놓은 것
        특히, 컴퓨터과학에서 알고리즘이란 컴퓨터가 따라 할 수 있도록 자세히 설명한 과정

    예시 )   1. 1등부터 20등까지의 점수 평균을 내는 방법 => 3가지 (p.88)
            2. 서울 신촌역에서 춘천에 갈 때(비교)      => 2가지 (p.89)

    알고리즘을 평가하는 두 가지의 큰 기준은 시간과 공간 (자세한 설명 p.90)
    =>  이 두 기준은 서로 상충하는 경우가 많다.
        물론 더 빠르면서 메모리도 더 적게 사용하는 알고리즘이 있을 수는 있지만,
        메모리 사용량을 희생해 속도를 높이거나, 속도를 희생해서 메모리 사용량을 줄인 알고리즘들을 훨씬 자주 볼 수 있다.

        동적 계획법(8장) -> 더 많은 메모리를 사용해 알고리즘의 수행 속도를 높이는 대표적인 예
        프로그래밍 대회에서는 주로 중요시되는 알고리즘의 기준은 속도이다.

    2부는 '알고리즘의 속도를 분석하는 방법'과 '알고리즘의 정당성을 증명하는 기술들'을 소개



04. 알고리즘의 시간 복잡도 분석
    4.1 도입
        좀더 빠른 알고리즘을 만들기 위해 가장 먼저 해야 할 일은 바로 '알고리즘의 속도를 어떻게 측정할지를 정하는 것'이다.

        '두 알고리즘의 속도를 비교하는 가장 직관적인 방법'은 '각각을 프로그램으로 구현한 뒤 같은 입력에 대해 두 프로그램의 수행 시간을 측정하는 것'이다.
        하지만 프로그램의 실행 시간은 알고리즘의 속도를 일반적으로 이야기하는 기준이 되기에는 부적합하다.
        이유)    1. 프로그램의 수행 시간은 사용한 프로그래밍 언어, 하드웨어, 운영체제, 컴파일러까지 수많은 요소에 의해 바뀔 수 있기 때문이다.
                    심지어 이런 외적 요인을 전부 통일하더라도 어떤 문자열 구현을 사용했는지, 
                    함수 인자를 어떻게 넘겼는지 등의 사소한 문제에 따라 프로그램의 최종 수행 시간은 크게 달라질 수 있다.
                2. 프로그램의 실제 수행 시간이 "다양한 입력에 대한 실행 시간을 반영하지 못한다는 것"이다.
                    알고리즘은 언제나 같은 속도로 동작하는 것이 아니며, 입력의 크기나 특성에 따라 수행 시간이 달라질 수 있다.
    
        - 반복문이 지배한다
            예시) 서울에서 부산까지 가야하는데, 어느 자동차를 타고 가야 더 빨리 도착할 수 있을지 (자동차, 자전거)

            =>  "알고리즘의 수행 시간을 지배하는 것은 반복문"이다.
                물론 입력에 상관 없이 항상 같은 수행 시간을 갖는 알고리즘도 있지만, 대개는 입력의 크기에 따라 수행 횟수가 정해지는 반복문이 있기 마련이다.
                짧은 거리를 달릴 때는 자전거가 빠를 수 있는 것처럼 입력의 크기가 작을 때는 반복 외의 다른 부분들이 갖는 비중이 클 수 있지만,
                입력의 크기가 커지면 커질수록 반복문이 알고리즘의 수행 시간을 지배하게 된다.
                따라서 대개 우리는 "알고리즘의 수행 시간"을 "반복문이 수행되는 횟수로 측정"한다.
                이때 "반복문의 수행 횟수"는 "입력의 크기에 대한 함수로 표현"한다.

            code_4.1 => 알고리즘의 수행 시간은 N^2 (p.93)

            code_4.2
                설정)    입력으로 주어지는 숫자들이 사실 100점 만점으로 주어지는 중간 고사 점수였다고 하자.
                        이처럼 숫자의 범위가 작다면 배열을 이용해 각 숫자가 등장하는 횟수를 쉽게 셀 수 있다.
                        그리고 마지막에 빈도수 배열을 순회하면서 최대치의 위치를 찾으면 된다.
                분석)    이 코드에는 반복문이 두 개 있다. 하나는 N번 수행되고, 다른 하나는 100번 수행되므로 전체 반복문의 수행 횟수는 N+100이 된다. 
                        그런데 N이 커지면 커질수록 사실 후자의 반복문은 수행 시간에서 차지하는 비중이 줄어들게 된다. (4.5절 내용)
                        따라서 궁극적으로는 이 "알고리즘의 수행 시간은 N"이다.
                내 생각)  메모리 사용량을 희생해 속도를 높였다.

            알고리즘의 수행 시간은 매우 종류가 다양하지만 크게 몇 가지 분류로 나눌 수 있다.
            대표적인 몇 가지 수행 시간의 형태로 살펴보면서 알고리즘 효율성 분석의 예제를 보도록 하자.



    4.2 선형 시간 알고리즘
        - 다이어트 현황 파악: 이동 평균(moving average) 계산하기
            배경)   이동 평균(moving average)은 주식의 가격, 연간 국내 총생산(GDP), 여자친구의 몸무게 등 시간에 따라 변화하는 값들을 관찰할 때 
                   유용하게 사용할 수 있는 통계적 기준이다.
                   시간에 따라 관찰된 숫자들이 주어질 때 M-이동 평균은 마지막 M개의 관찰 값의 평균으로 정의된다.
                   따라서 새 관찰 값이 나오면 M-이동 평균은 새 관찰 값을 포함하도록 바뀝니다.
            
            code_4.3
                분석)  이 코드의 수행 시간은 두 개의 for문에 의해 지배된다.
                      j를 사용하는 반복문은 항상 M번 실행되고 i를 사용하는 반복문은 N-M+1번 실행되니, 전체 반복문은 M*(N-M+1)번 반복된다.
            
            code_4.4
                분석)  여기에서 중요한 아이디어는 '중복된 계산을 없애는 것'이다.
                      
                      M-1일의 이동 평균과 M일의 이동 평균에 포함되는 숫자들을 생각해보자.
                      실제 이 둘은 0일과 M일의 몸무게를 제외하면 전부 겹친다는 것을 알 수 있다.
                      그러면 측정한 몸무게의 합을 일일이 구할 것 없이 M-1일에 구했던 몸무게의 합에서 0일째에 측정한 몸무게를 빼고 M일 째에 측정한 몸무게를 더하면 된다.

                      이 프로그램의 반복문 수행 횟수는 M-1+(N-M+1)=N 이다.

                      코드 4.4의 수행 시간은 N에 정비례한다. N이 두 배 커지면 실행도 두 배 오래 걸리고, 반으로 줄어들면 수행 시간도 반을 줄어든다.
                      "입력의 크기에 대비해 걸리는 시간을 그래프로 그려 보면 정확히 직선"이 된다. 때문에 이런 알고리즘을 "선형 시간(linear time) 알고리즘"이라고 부른다.
                      선형 시간에 실행되는 알고리즘은 대개 우리가 찾을 수 있는 알고리즘 중 가장 좋은 알고리즘인 경우가 많다.


    
    4.3 선형 이하 시간 알고리즘
        - 성형 전 사진 찾기
            배경)   어떤 문제건 입력된 자료를 모두 한 번 훑어보는 데에는 입력의 크기에 비례하는 시간, 즉 선형 시간이 걸립니다.
                   그럼 선형 시간보다 빠르게 동작하는 알고리즘들은 입력된 자료를 다 보지도 않는단 말인데, 과연 이런 알고리즘이 어떻게 존재할 수 있을까?
                   입력으로 주어진 자료에 대해 우리가 미리 알고 있는 지식을 활용할 수 있다면 이런 일이 가능하다. (=> 내 생각. 정렬)

            예시)   성형 전 사진 찾기(p.97)
            분석)   이때 봐야 하는 사진의 장수를 N에 대해 표현하면 어떻게 될까? N을 계속 절반으로 나눠서 1 이하가 될 때까지 몇 번이나 나눠야 하는지로 알 수 있는데, 
                   이것을 나타내는 함수가 바로 로그이다. 매번 절반씩 나누니 밑이 2인 로그 log2를 사용하면 된다. (이 이후에는 간단하게 lg라고 줄여 쓰도록 하겠다.)
                   따라서 확인해야 하는 사진의 장수는 대략 lgN이라고 할 수 있다.
                   lg는 굉장히 느리게 증가하는 함수이다. 만약 지구에서 달까지 닳도록 A군의 사진을 1.5조 장을 쌓아 놓더라도 이 중에서 원하는 성현 전 사진을 마흔 장만 보고
                   찾아낼 수 있다. 이와 같이 "입력의 크기가 커지는 것보다 수행 시간이 느리게 증가하는 알고리즘들"을 "선형 이하 시간(sublinear time) 알고리즘"이라고 한다.
        
        - 이진 탐색
            방근 전 예제에서 사용한 알고리즘을 이진 탐색(binary search)이라고 부른다.
            이 알고리즘은 누구나 사전을 찾을 때(이제는 전자사전을 쓰지만), 혹은 전화번호부를 뒤질 때(이제는 검색을 하겠지만) 한 번쯤 이용했을 만한 간단한 아이디어에 기반한 것으로,
            이 책에 실린 모든 알고리즘 중 가장 유용하게 쓰이는 것 중 하나일거다. 이진 탐색 알고리즘이 하는 일을 다음과 같이 정의할 수 있다.

            정의)       binsearch(A[], x) := 오름차순으로 정렬된 배열 A[]와 찾고 싶은 값 x가 주어질 때 A[i-1]<x<=A[i]인 i를 반환한다. 
                       이때 A[-1]=-무한, A[N]=+무한로 가정한다.  (내 생각. 0부터 N-1까지 존재하니깐)
            이 함수가 배열 A[]에서 x를 삽입할 수 있는 위치 중 가장 앞에 있는 것을 반환한다고 생각하면 좀더 쉽다.
            대개의 배열이나 리스트 구현에서 i번째 위치에 새 원소를 삽입한다는 것은 i번째와 그 이후의 원소들을 뒤로 한 칸씩 밀어내고 들어간다는 뜻이다.
            따라서 A[]에 x가 존재하는 경우 이 함수는 첫 번째 x의 위치를 반환하고, 없는 경우 x보다 큰 첫 번째 원소를 반환한다.

            참고)       C++의 표준 라이브러리에는 이진 탐색 함수가 두 개 존재한다. x를 삽입할 수 있는 위치 중 가장 이른 것을 반환하는 lower_bound()와 
                       가장 뒤의 것을 반환하는 upper_bound()가 있다. (내 생각. binsearch(A[], x) = lower_bound())

            예제 적용)   위와 같은 일을 하는 이진 탐색 함수 binsearch(A[], x)가 있다고 할 때, 선형 전 사진 찾는 문제를 어떻게 풀 수 있을까?
                       길이 N인 정수 배열 A[]를 만들어 각 원소가 가장 일찍 찍힌 사진부터 차례대로 하나의 사진을 표현하도록 하자.
                       이때 각 원소의 값은 해당 사진에서 A군이 성형을 했을 경우 1로, 성형을 하지 않았을 경우 0으로 하도록 하자.
                       그러면 A는 {0, 0, ~, 1, 1, ~, 1, 1}과 같은 형태를 갖게 될 거다. binsearch()를 이용해 여기에서 A[i-1]<1<=A[i]인 i를 찾으면
                       1의 첫 번째 위치를 찾을 수 있다. 결과적으로 i-1번 사진과 i번 사진 사이에 성형을 했다는 것을 알 수 있다.

            내 생각) sublinear time algorithm 중에 binary search가 있다.

        - 그래도 선형 시간 아닌가요?
            그런데 이 설명대로라면 binsearch()의 입력을 만들기 위해서는 결국 사람이 모든 사진을 보면서 성형 이전인지 여부를 판단해야 한다.
            게다가 그 전에는 10만 개의 사진을 전부 다운받고 시간 순으로 정렬해야 한다. 따라서 이 알고리즘이 탐색 과정에서 얼마가 걸리건 간에 전체는 선형 시간이 걸리는 게 아닌가
            하는 의문이 들 수 있다. 하지만 우리는 다음과 같은 이유 때문에 이렇게 분석하지 않는다.

            이유)   1. A[]를 실제로 계산해서 갖고 있을 필요가 없다.
                   2. 사진을 다운받고 정렬해 두는 과정은 실제로 성형 전 사진을 찾는 작업과는 별개이다.
                        (자세한 내용은 p.100)

        - 구현
            간단한 아이디어와는 달리 이진 탐색을 정확하게 구현하기는 매우 까다롭다. 따라서 이 알고리즘의 구현은 알고리즘의 정당성을 증명하는 방법을 다루는 5.2절에서 다시 살펴보자.

    

    4.4 지수 시간 알고리즘
        - 다항 시간 알고리즘
            - 다항 시간 알고리즘 정의
                변수 N과 N^2, 그 외 N의 거듭제곱들의 선형 결합으로 이루어진 식들을 다항식이라고 부른다. 
                "반복문의 수행 횟수를 입력 크기의 다항식으로 표현할 수 있는 알고리즘"들을 "다항 시간 알고리즘"이라고 부른다.

            - 다항 시간 알고리즘을 따로 정의한 이유
                앞에서 언급한 선형 시간이나 선형 이하 시간과는 달리, 다항 시간이라는 하나의 분류에 포함되는 알고리즘 간에는 엄청나게 큰 시간 차이가 날 수 있다. 
                N이나 N^2도 다항 시간이지만, N^6도, N^42도, 심지어는 N^100도 다항 시간이기 때문이다. 때문에 이 알고리즘이 다항 시간이라고 말하는 것만으로는 
                이 알고리즘이 충분히 빠르다고 할 수 없다. 그렇다면 왜 이들을 묶어서 이름을 붙인 것일까? 다항 시간보다 더더욱 오랜 시간이 걸리는 알고리즘들이 있기 때문이다.

        - 알러지가 심한 친구들
            예제) p.101
        
        - 모든 답 후보를 평가하기
            - 여러 개의 답이 있고 그중 가장 좋은 답을 찾는 문제들을 풀 때 가장 간단한 방법은 모든 답을 일일이 고려해 보는 것이다.
            (추가 : 그림을 직접 모두 표현, 그리기 (자세한 설명은 p.102))

            - 알고리즘 분석 (p.102)

            - 이런 알고리즘을 구현하는 가장 쉬운 방법은 재귀 호출을 이용하는 것이다. (6장에서 더 자세히 다룬다.) 
                    이때 재귀 함수는 그림에서의 한 상태를 입력받아 이 상태 밑에 달린 모든 후보들을 검사하고 이 중 가장 좋은 답을 반환하는 역할을 한다. 
                    코드 4.5에서 이 알고리즘의 구현을 볼 수 있다. selectMenu()는 지금까지 만들기로 정한 메뉴와 몇 번 음식을 결정할 차례인지를 
                    입력받아 가능한 모든 메뉴를 하나씩 시도해 본다.

            code_4.5

        - 지수 시간 알고리즘
            - 시간 복잡도 분석
                우리의 프로그램은 모든 답을 한 번씩 다 확인하기 때문에, 전체 걸리는 시간은 만들 수 있는 답의 수에 비례한다. M가지의 음식마다 두 선택지가 있으니 
                우리가 만들 수 있는 답은 모두 2^M가지이다. 답을 하나 만들 때마다 canEverybodyEat()을 수행하니 이 알고리즘의 수행 시간은 2^M에 
                canEverybodyEat()의 수행 시간을 곱한 것이 된다. canEverybodyEat()을 수행할 때 반복문이 N*M번 수행된다고 가정하면 전체 수행 시간은 N*M*2^M이 된다.
            
            - 2^M과 같은 지수 함수는 알고리즘의 전체 수행 시간에 엄청난 영향을 미친다.

            - exponential time algorithm 정의
                이와 같이 N이 하나 증가할 때마다 걸리는 시간이 배로 증가하는 알고리즘들은 지수 시간(exponential time)에 동작한다고 한다. 
                지수 시간은 가장 큰 수행 시간 중 하나로, 입력의 크기에 따라 다항 시간과는 비교도 안 되게 빠르게 증가한다.

            - 지수 시간 알고리즘보다 빠른 알고리즘이 존재할까?
                그런데 이 알고리즘이 이렇게 오래 걸리는 이유는 어디까지나 이 알고리즘의 무식하기 때문이겠죠? 이것보다 훨씬 빠른 알고리즘이 있겠죠? 아닙니다.
                지수 시간보다 빠른 알고리즘을 찾지 못한 문제들이 전산학에는 쌓이고 쌓였다. 우리가 여기에서 다룬 이 문제는 사실 집합 덮개(set cover)라고 부르는 유명한 문제로 
                아직까지 다항 시간 알고리즘이 존재한다는 증거도, 존재하지 않는다는 증거도 발견되지 않았다.
                
            - P-NP의 예습 ???
                이처럼 아직 지수 시간보다 빠른 알고리즘을 찾아내지 못한 문제들이 아주 많기 때문에, 다항 시간과 지수 시간 사이의 경계는 현재의 전산학에서 
                효율적으로 해결할 수 있는 문제와 효율적으로 해결하는 방법을 아직 찾아내지 못한 문제의 경계 역할을 하고 있다. 
                때문에 다항 시간 알고리즘이 있는 문제는 계산적으로 쉬운 문제, 아직 없는 문제는 계산적으로 어려운 문제라고 이야기한다. (=> 4.7절)

            - 지수 시간이 걸리는 문제들을 다항 시간으로 바꿀 수 있을까 ???
                물론 계산적으로 어려운 문제들이라고 해서 더 잘할 수 있는 방법이 없는 것은 아니다. 예를 들어 11장에서 다루는 기법들은 지수 시간이 걸리는 문제들을 좀더 효율적으로
                해결할 수 있는 방법을 보여준다. 그러나 이들이 지수 시간을 다항 시간으로 바꿔주지는 못하며, 어디까지나 조금 더 빠르게 동작할 뿐이다.
        
        - 소인수 분해의 수행 시간
            code_4.6
                자연수 N이 주어질 때 N의 소인수 분해 결과를 반환하는 간단한 알고리즘을 보여준다. 이 알고리즘은 N이 1이 될 때까지 가능한 한 모든 숫자로 N을 나눠 본다.
                따라서 N의 크기에 따라 반복문의 수행 횟수가 달라지게 된다.

            - 입력으로 주어지는 숫자의 개수가 아니라 그 크기에 따라 수행 시간이 달리지는 알고리즘들 또한 지수 수행 시간을 가질 수 있다.
                가능한 최악의 경우는 얼마일까요? 이 코드에서 반복문이 가장 많이 실행되는 경우는 주어진 수 N이 소수인 경우이다. 이때 factor()는 div가 N에
                도달할 때까지 숫자를 증가시키며 하나하나 나누기를 시도한다. 결과적으로 반복문의 실행 횟수는 N-1이 된다. 실행 횟수가 대략 N에 비례하기 때문에
                이 함수는 최악의 경우에 선형 시간이 걸린다고 생각하기 쉽다. 그런데 N이 아무리 커져도 실제 입력은 1개일 뿐인데 수행 시간이 달라진다는 것은 영 우리의
                직관에 맞지 않는 것 같다.

            - 코드 4.6이 exponential time algortihm 인 이유
                이런 불일치를 직관적으로 이해하기 위해 알고리즘의 수행 시간과 입력이 메모리에서 차지하는 공간의 관계를 생각해보자.
                이진 탐색, 이동 평균 계산 등 지금까지 다룬 알고리즘에서는 입력의 값들이 일정 범위 내에 있다고 어렵지 않게 가정할 수 있다.
                이 경우 입력의 개수와 메모리에서 차지하는 공간이 직접적으로 비례한다.
                반면 소인수 분해 문제에서는 입력으로 주어지는 숫자가 알고리즘의 동작에 직접적인 영향을 미치므로, 숫자가 특정 범위 안에 있다고 가정할 수 없다.
                입력의 값이 커지면 커질수록 숫자를 저장하는데 필요한 메모리의 공간도 증가할 것이다. 이때 "입력의 차지하는 비트의 수에 따라 수행 시간이 증가한다고
                생각하면 아까의 불일치를 직관적"으로 설명할 수 있다. 비트의 수가 하나 증가할 때마다 표현할 수 있는 수의 범위와 알고리즘의 최대 수행 시간은 두 배로
                증가한다. 이렇게 "입력의 크기를 입력이 차지하는 비트 수로 정의"하면 코드 4.6은 입력의 크기에 대해 지수 시간이 걸린다고 발할 수 있다.



