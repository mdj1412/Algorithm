[ 3부 알고리즘 설계 패러다임 ]

- 개관
    : 알고리즘을 고안하는 것은 까다로운 작업이다. 코드를 고치는 고역을 겪어 본 사람들은 모두 알고리즘 설계가 얼마나 어려운 일인지를 실감했을 것이다.
        ex) 복잡한 요구사항을 프로그램으로 작성해야 할 때 감도 오지 않은 채로 멍하니 모니터만 쳐다본 경험이 있거나, 요구사항에 대해 깊이 생각하지 않은 채 우선 타이핑을 
            시작했다가 엉망으로 꼬인 경우

    : 알고리즘 설계 ?
        흔히 상상하는 것과는 달리 알고리즘을 설계하는 작업은 한순간의 영감보다는 '여러 전략적인 선택에 따라 좌우'한다. 알고리즘을 고안하기 위해서는 
        "해결할 문제의 특성을 이해하고, 동작 시간과 사용하는 공간 사이의 상충 관계를 이해해야 하며, 적절한 자료 구조를 선택할 줄 알아야한다."

    : 알고리즘 설계 패러다임 ?
        알고리즘 설계 패러다임이란 "주어진 문제를 해결하기 위해 알고리즘이 채택한 전략이나 관점"을 말한다. 어떤 알고리즘들은 문제를 해결하기 위한 가장 중요한 깨달음을 공유하는데,
        이와 같은 깨달음을 모아 보면 '일종의 패턴'을 확인할 수 있다. 이런 의미에서 이들은 같은 전략, 혹은 같은 설계 패러다임을 통해 문제를 해결했다고 말한다.

    : 앞으로 왜, 무엇을 배울까 ?
        알고리즘 설계 패러다임들은 알고리즘 설계를 위한 좋은 틀이 되기 때문에, 이들에 대해 공부하는 것은 알고리즘 설계 능력을 키우는 좋은 방법이다.
        다음 장들에서는 컴퓨터 과학의 역사를 바꾼 중요한 알고리즘 설계 패러다임들에 대해 소개한다.
        우리는 고전적이고 단순한 기법들로부터 시작해, 각 설계기법에 필요한 직관들을 논의하고 단순한 기법들로부터 시작해, 각 설계기법에 필요한 직관들을 논의하고 이것을 발전시켜
        패러다임의 틀을 만들어 나갈 것이다.

    내 생각) 알고리즘 설계 패러다임은 알고리즘 설계의 부분집합

06. 무식하게 풀기
    - 6.1 도입
        : 무식하게 푸는 것이 나쁜 것일까 ? 무식하게 푸는 방법도 생각해보자 !
            프로그래밍 대회에서 대부분의 사람들이 가장 많이 하는 실수는 쉬운 문제를 어렵게 푸는 것이다. 공부를 열심히 할수록 복잡하지만 우아한 답안을 만들고 싶은 마음이
            커지기 마련이고, 그래서 바로 앞에 보이는 쉽고 간단하며 틀릴 가능성이 낮은 답안을 간과하기 쉽다.
            이런 실수를 피하기 위해 문제를 마주하고 나면 가장 먼저 스스로에게 물어보자. 무식하게 풀 수 있을까?

        : 무식하게 푼다(brute-force) 정의
            흔히 전산학 '무식하게 푼다(brute-force)'는 말은 "컴퓨터의 빠른 계산능력을 이용해 가능한 경우의 수를 일일이 나열하면서 답을 찾는 방법을 의미"한다.

            ex. ( 무식한 알고리즘의 좋은 예 )
                1. 두 점 사이의 최단 경로를 찾는 문제라면 두 점 사이의 경로들을 하나하나 전부 만들어서 그중 가장 짧은 것을 찾는 방법
                2. 자원을 분배할 수 있는 경우의 수를 세는 문제라면 한 가지씩 분배 방법을 전부 만들어 보는 알고리즘

        : 완전 탐색(exhaustive search) 정의
            이렇게 "가능한 방법을 전부 만들어 보는 알고리즘들"을 가리켜 흔히 "완전 탐색(exhaustive search)"이라고 부른다.
            컴퓨터의 최대 장점은 속도가 빠르다는 것이기 때문에, 완전 탐색은 "컴퓨터의 장점을 가장 잘 이용하는 방법"이다.
            특히 현실 세계의 문제 중에는 입력의 크기가 작아 컴퓨터가 처리하기에는 별 것 아니지만 손으로 직접 풀기에는 경우의 수가 너무 많은 경우가 종종 있는데,
            이럴 때 완전 탐색은 충분히 빠르면서도 가장 구현하기 쉬운 대안이 된다.

        : 완전 탐색 예시 + 분석 (p.145)
            ex. 열 명의 학생을 한 줄로 세우려고 하는데, 서로 사이가 안 좋은 학생들이 있다고 하자. 이 학생들을 서로 붙여서 세우면 싸움이 나기 때문에,
                이들을 서로 떨어뜨려서 세우는 방법이 있는지 알고 싶다.
            -> 완전탐색을 쓰면 어떻게 쉽게 푸는 방법이 없을까 고민할 필요 없이, 무식하지만 훨씬 간편하게 문제를 풀어낼 수 있다.
        
        : 프로그래밍 대회에서 ...
            실제로 프로그래밍 대회에서도 프로그램을 빠르고 정확하게 구현하는 능력을 검증하기 위해 입력의 크기를 작게 제한한 문제들이 흔히 출제하며,
            완전 탐색은 더 빠른 알고리즘의 기반이 되기도 하기 때문에 완전 탐색에 대해 잘 익혀둘 필요가 있다.
        


        구글링) https://rebro.kr/59
            완전 탐색 : 컴퓨터의 빠른 계산 능력을 이용하여 가능한 경우의 수를 일일이 나열하면서 답을 찾는 방법
            완전 탐색(exhaustive search) ~ 무식하게 푼다 : Brute-Force ( 브루트 포스 )

            사실 완전 탐색 자체로는 알고리즘이라고 부르긴 그렇고, 문제 푸는'방법'이라고 이해하면 편할 것 같다. 
            알고리즘을 모르는 사람이 프로그래밍 문제를 푼다면, 당연히 가능한 모든 경우들을 다 구해서 그중에 만족하는 답을 찾아낼 것이고 이 과정 자체가 완전 탐색이다.

            장점 : 장점으로는 답을 무조건 찾을 수 있다. 
            단점 : 답을 찾는데 시간이 걸린다.

            완전 탐색 기법 종류 :
                1. 단순 Brute-Force : 어느 기법을 사용하지 않고 단순히 for문과 if문 등으로 모든 case들을 만들어 답을 구하는 방법

                2. 비트 마스크(Bitmask) : 2진수를 이용하는 컴퓨터의 연산을 이용하는 방식
                    완전 탐색에서 비트마스크는 문제에서 나올 수 있는 모든 경우의 수가 각각의 원소가 포함되거나, 포함되지 않는 두 가지 선택으로 구성되는 경우에 유용하게 사용이 가능

                3. 재귀 함수 :

                4. 순열 (Permutation) : 완전 탐색의 대표적인 유형
                    서로 다른 N개를 일렬로 나열하는 순열의 경우의 수는 N! 이므로 완전 탐색을 이용하기 위해서는 N이 한자리 수 정도는 되어야 한다. 
                    순열에 원소를 하나씩 채워가는 방식이며, 재귀 함수를 이용하거나 C++에서는 next_permutation이라는 아주 유용한 함수를 제공하고 있다. 

                5. BFS / DFS : 약간의 난이도가 있는 문제로 완전 탐색 + BFS/DFS 문제가 많이 나온다. 
                    대표적인 유형으로 길 찾기 문제가 있다. 
                    단순히 길을 찾는 문제라면 BFS/DFS만 이용해도 충분하지만, 주어진 도로에 장애물을 설치하거나, 
                    목적지를 추가하는 등의 추가적인 작업이 필요한 경우에 이를 완전 탐색으로 해결하고 나서, BFS/DFS를 이용하는 방식이다. 




    - 6.2 재귀 호출과 완전 탐색
        - 재귀 호출
            : 컴퓨터가 수행하는 많은 작업들이 대개 작은 조각으로 나누어 볼 수 있다.
                ex) 1. 인터넷에서 물건을 구매하는 작업은 카드회사에 정보를 보내기, 데이터베이스 갱신, 결제 완료 이메일을 보내기 등으로 나눌 수 있다.
                    2. 문자열의 길이를 세는 작업은 첫 한 글자를 세기, 다음 한 글자 세기, 다음 한글자를 세기... 라는 조각들로 나눌 수 있다.
            
            : 재귀 함수(recursive function), 재귀(recursion)은 언제 사용할까 ?
                그런데 우리가 들여다보는 범위가 작아지면 작아질수록 각 조각들의 형태가 유사해지는 작업들을 많이 볼 수 있다.
                완전히 같은 코드를 반복해 실행하는 for 같은 반복문이 좋은 예다.
                이런 작업을 구현할 때 유용하게 사용되는 개념이 바로 재귀 함수(recursive function), 혹은 재귀 호출(recursion)이다.
            
            : 재귀 함수(recursive function) ?
                재귀 함수란 "자신이 수행할 작업을 유사한 형태의 여러 조각으로 쪼갠 뒤 그 중 한 조각을 수행하고, 나머지를 자기 자신을 호출해 실행하는 함수"를 가리킨다.
                이렇게 들으면 꽤나 쓸데없어 보이지만 재귀 호출은 다양한 알고리즘을 구현하는 데 매우 유용하게 사용할 수 있는 도구이다.
                재귀 호출의 기초적인 성질을 이해하기 위해 가장 간단한 반복문을 재귀 함수로 바꿔 구현해 보자.
            
            : code_6.1 => 자연수 n이 주어졌을 때 1부터 n까지의 합을 반환하는 함수 sum()의 구현을 보여준다.
                이 함수를 어떻게 하면 재귀 호출을 이용하도록 바꿀 수 있을까?
                분석) p.147
                주의할 점)  한 가지 유의할 것은 n개의 조각 중 n이 아니라 1을 빼냈을 경우 이런 방법으로 문제를 해결할 수 있다는 것이다.
                          1을 빼고 나면 2부터 n까지의 합이 남는데, 이것은 1부터 n까지의 합을 구한다는 원래 문제와는 다른 형태이고 
                          따라서 sum()을 호출해 계산할 수 없기 때문이다.

            : 기저 사례(base case) 정의
                recursiveSum() 함수의 첫 줄에 있는 if문에 주목해 보자. 이 조건문이 없으면 이 함수가 제대로 동작하지 않을 것임은 자명한다.
                n = 1이면 조각이 하나뿐이니, 한 개를 빼고 나면 더이상 처리할 작업이 없기 때문이다.
                "모든 재귀 함수는 이와 같이 '더이상 쪼개지지 않는' 최소한의 작업에 도달했을 때 답을 곧장 반환하는 조건문을 포함해야 한다."
                이때 "쪼개지지 않는 가장 작은 작업들"을 가리켜 "재귀 호출의 기저 사례(base case)"라고 한다.

            : 기저 사례(base case)의 선택 ?
                기저 사례를 선택할 때는 존재하는 모든 입력이 항상 기저 사례의 답을 이용해 계산될 수 있도록 신경써야 한다.
                만약 recursiveSum()에서 n이 1인 경우를 확인하는 것이 아니라 n이 2인지 확인하고, 2라면 3을 반환한다고 가정해 보자.
                이렇게 구현하더라도 입력이 2 이상이라면 아무 문제 없이 답을 모두 계산할 수 있지만 1이 입력으로 들어오면 문제가 생기게 된다.

            : 문제의 특성에 따라 재귀 호출은 코딩을 훨씬 간단하게 해 줄 수 있는 강력한 무기가 된다.
                재귀 호출은 기존에 반복문을 사용해 작성하던 코드를 다르게 짤 수 있는 방법을 제공해 준다.
                이 함수에서도 기존의 코드에 비해 재귀 호출을 통해 얻을 수 있는 별다른 이득이 없었지만, 문제의 특성에 따라 재귀 호출은 코딩을 훨씬 간단하게 해 줄 수 있는 
                강력한 무기가 된다.

        - 예제: 중첩 반복문 대체하기